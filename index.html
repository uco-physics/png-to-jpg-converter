<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>メッシュワープ（逆写像＋三角形補間＋ペン機能）</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    #container { position: relative; display: inline-block; }
    canvas { border: 3px solid #000; background: #f0f0f0; }
    #gridContainer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .grid-point {
      position: absolute;
      width: 10px; height: 10px;
      background: rgba(255,0,0,0.8);
      border-radius: 50%;
      transform: translate(-50%,-50%);
      cursor: move;
      pointer-events: auto;
    }
    .controls { margin: 20px 0; }
    button, input[type=range], input[type=color] { margin: 5px; padding: 5px; }
    #error { color: red; }
    .tool-button { padding: 8px 12px; cursor: pointer; }
    .tool-button.active { background: #ddd; }
  </style>
</head>
<body>
  <h1>メッシュワープ（逆写像＋三角形補間＋ペン機能）</h1>
  <div class="controls">
    <input type="file" id="imageInput" accept="image/*">
    <label>横分割: <input type="range" id="gridX" min="2" max="50" value="5"><span id="gridXValue">5</span></label>
    <label>縦分割: <input type="range" id="gridY" min="2" max="50" value="5"><span id="gridYValue">5</span></label>
    <div>
      <label>ツール:
        <button id="penTool" class="tool-button active">ペン</button>
      </label>
    </div>
    <div>
      <label>色: <input type="color" id="penColor" value="#000000"></label>
      <label>太さ: <input type="range" id="penWidth" min="1" max="20" value="5"><span id="penWidthValue">5</span></label>
    </div>
    <button onclick="resetGrid()">リセット</button>
    <button onclick="undo()">戻る</button>
    <button onclick="redo()">進む</button>
    <button onclick="saveImage()">保存</button>
    <div id="error"></div>
  </div>

  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="gridContainer"></div>
  </div>

  <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const imgInput = document.getElementById('imageInput');
  const gridXInput = document.getElementById('gridX');
  const gridYInput = document.getElementById('gridY');
  const gridXValue = document.getElementById('gridXValue');
  const gridYValue = document.getElementById('gridYValue');
  const gridContainer = document.getElementById('gridContainer');
  const errorDiv = document.getElementById('error');
  const penTool = document.getElementById('penTool');
  const penColor = document.getElementById('penColor');
  const penWidth = document.getElementById('penWidth');
  const penWidthValue = document.getElementById('penWidthValue');

  let img = new Image();
  let imgData = null;
  let gridPoints = [];
  let gridX = 5, gridY = 5;
  let isDragging = false, draggedIndex = null;
  let history = [], historyIdx = -1;
  let tool = 'pen';
  let isDrawing = false;
  let lastPoint = null;
  let drawCanvas = document.createElement('canvas');
  let drawCtx = drawCanvas.getContext('2d');

  function showError(msg) {
    errorDiv.textContent = msg;
    console.error(msg);
  }

  // 画像読み込み
  imgInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return showError('画像を選択してください');
    try {
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        drawCanvas.width = img.width;
        drawCanvas.height = img.height;
        ctx.imageSmoothingEnabled = true;
        drawCtx.imageSmoothingEnabled = true;
        console.log('画像読み込み完了:', img.width, 'x', img.height);
        initGrid();
        saveHistory();
        ctx.drawImage(img, 0, 0);
        imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        draw();
        errorDiv.textContent = '';
      };
      img.onerror = () => showError('画像読み込み失敗');
    } catch (err) {
      showError('画像処理エラー: ' + err.message);
    }
  });

  // グリッド初期化
  function initGrid() {
    try {
      gridContainer.innerHTML = '';
      gridPoints = [];
      if (gridX > 30 || gridY > 30) showError('分割数が多いと重くなります');
      for (let y = 0; y <= gridY; y++) {
        for (let x = 0; x <= gridX; x++) {
          const px = x * (canvas.width / gridX);
          const py = y * (canvas.height / gridY);
          gridPoints.push({ x: px, y: py, origX: px, origY: py });
          createPoint(px, py, gridPoints.length - 1);
        }
      }
      console.log('グリッド初期化完了:', gridX, 'x', gridY);
    } catch (err) {
      showError('グリッド初期化エラー: ' + err.message);
    }
  }
  function createPoint(x, y, i) {
    const d = document.createElement('div');
    d.className = 'grid-point';
    d.style.left = x + 'px';
    d.style.top = y + 'px';
    d.onmousedown = e => {
      isDragging = true;
      draggedIndex = i;
      e.stopPropagation();
    };
    gridContainer.appendChild(d);
  }
  function updateDOM() {
    try {
      gridPoints.forEach((p, i) => {
        const d = gridContainer.children[i];
        d.style.left = p.x + 'px';
        d.style.top = p.y + 'px';
      });
    } catch (err) {
      showError('DOM更新エラー: ' + err.message);
    }
  }

  // ヒストリ
  function saveHistory() {
    try {
      history = history.slice(0, historyIdx + 1);
      history.push({
        grid: JSON.stringify(gridPoints),
        draw: drawCanvas.toDataURL()
      });
      historyIdx++;
      if (history.length > 50) {
        history.shift();
        historyIdx--;
      }
      console.log('履歴保存:', historyIdx);
    } catch (err) {
      showError('履歴保存エラー: ' + err.message);
    }
  }
  function undo() {
    try {
      if (historyIdx > 0) {
        historyIdx--;
        const state = history[historyIdx];
        gridPoints = JSON.parse(state.grid);
        loadDrawCanvas(state.draw);
        updateDOM();
        draw();
      }
    } catch (err) {
      showError('Undoエラー: ' + err.message);
    }
  }
  function redo() {
    try {
      if (historyIdx < history.length - 1) {
        historyIdx++;
        const state = history[historyIdx];
        gridPoints = JSON.parse(state.grid);
        loadDrawCanvas(state.draw);
        updateDOM();
        draw();
      }
    } catch (err) {
      showError('Redoエラー: ' + err.message);
    }
  }
  function loadDrawCanvas(dataUrl) {
    try {
      const tempImg = new Image();
      tempImg.src = dataUrl;
      tempImg.onload = () => {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        drawCtx.drawImage(tempImg, 0, 0);
      };
    } catch (err) {
      showError('描画キャンバス復元エラー: ' + err.message);
    }
  }
  function resetGrid() {
    try {
      gridPoints.forEach(p => {
        p.x = p.origX;
        p.y = p.origY;
      });
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      updateDOM();
      saveHistory();
      draw();
    } catch (err) {
      showError('リセットエラー: ' + err.message);
    }
  }

  gridXInput.oninput = () => {
    try {
      gridX = +gridXInput.value;
      gridXValue.textContent = gridX;
      initGrid();
      saveHistory();
      draw();
    } catch (err) {
      showError('横分割変更エラー: ' + err.message);
    }
  };
  gridYInput.oninput = () => {
    try {
      gridY = +gridYInput.value;
      gridYValue.textContent = gridY;
      initGrid();
      saveHistory();
      draw();
    } catch (err) {
      showError('縦分割変更エラー: ' + err.message);
    }
  };

  // ペンの太さ更新
  penWidth.oninput = () => {
    penWidthValue.textContent = penWidth.value;
  };

  // ドラッグとペン描画
  canvas.addEventListener('mousedown', e => {
    if (isDragging) return;
    try {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (tool === 'pen') {
        isDrawing = true;
        lastPoint = { x, y };
        drawCtx.beginPath();
        drawCtx.moveTo(x, y);
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';
        drawCtx.strokeStyle = penColor.value;
        drawCtx.lineWidth = penWidth.value;
      }
    } catch (err) {
      showError('マウスダウンエラー: ' + err.message);
    }
  });
  document.addEventListener('mousemove', e => {
    try {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (isDragging) {
        const p = gridPoints[draggedIndex];
        p.x = Math.max(0, Math.min(canvas.width, x));
        p.y = Math.max(0, Math.min(canvas.height, y));
        updateDOM();
        draw();
      } else if (isDrawing) {
        drawCtx.beginPath();
        drawCtx.moveTo(lastPoint.x, lastPoint.y);
        drawCtx.lineTo(x, y);
        drawCtx.stroke();
        lastPoint = { x, y };
      }
    } catch (err) {
      showError('マウスムーブエラー: ' + err.message);
    }
  });
  document.addEventListener('mouseup', e => {
    try {
      if (isDragging) {
        saveHistory();
        isDragging = false;
        draggedIndex = null;
      }
      if (isDrawing) {
        saveHistory();
        isDrawing = false;
        lastPoint = null;
      }
    } catch (err) {
      showError('マウスアップエラー: ' + err.message);
    }
  });

  // バイリニアサンプル
  function sampleBilinear(buf, sx, sy) {
    try {
      const w = canvas.width, h = canvas.height;
      sx = Math.max(0, Math.min(w - 1, sx));
      sy = Math.max(0, Math.min(h - 1, sy));
      const x0 = Math.floor(sx), y0 = Math.floor(sy);
      const x1 = Math.min(w - 1, x0 + 1), y1 = Math.min(h - 1, y0 + 1);
      const dx = sx - x0, dy = sy - y0;
      const i00 = (y0 * w + x0) * 4, i10 = (y0 * w + x1) * 4,
            i01 = (y1 * w + x0) * 4, i11 = (y1 * w + x1) * 4;
      const c00 = [buf[i00], buf[i00 + 1], buf[i00 + 2], buf[i00 + 3]];
      const c10 = [buf[i10], buf[i10 + 1], buf[i10 + 2], buf[i10 + 3]];
      const c01 = [buf[i01], buf[i01 + 1], buf[i01 + 2], buf[i01 + 3]];
      const c11 = [buf[i11], buf[i11 + 1], buf[i11 + 2], buf[i11 + 3]];
      const mix = (a, b, t) => a + (b - a) * t;
      const r = mix(mix(c00[0], c10[0], dx), mix(c01[0], c11[0], dx), dy);
      const g = mix(mix(c00[1], c10[1], dx), mix(c01[1], c11[1], dx), dy);
      const b = mix(mix(c00[2], c10[2], dx), mix(c01[2], c11[2], dx), dy);
      const a = mix(mix(c00[3], c10[3], dx), mix(c01[3], c11[3], dx), dy);
      return [r, g, b, a];
    } catch (err) {
      showError('バイリニアサンプルエラー: ' + err.message);
      return [0, 0, 0, 0];
    }
  }

  // 三角形逆写像
  function drawTriangle(v0, v1, v2, o0, o1, o2, outBuf, outW, outH) {
    try {
      const minX = Math.max(0, Math.floor(Math.min(v0.x, v1.x, v2.x)));
      const maxX = Math.min(outW - 1, Math.ceil(Math.max(v0.x, v1.x, v2.x)));
      const minY = Math.max(0, Math.floor(Math.min(v0.y, v1.y, v2.y)));
      const maxY = Math.min(outH - 1, Math.ceil(Math.max(v0.y, v1.y, v2.y)));
      const area = (v1.y - v2.y) * (v0.x - v2.x) + (v2.x - v1.x) * (v0.y - v2.y);
      if (Math.abs(area) < 1e-6) return; // 面積ゼロはスキップ
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const w0 = ((v1.y - v2.y) * (x - v2.x) + (v2.x - v1.x) * (y - v2.y)) / area;
          const w1 = ((v2.y - v0.y) * (x - v2.x) + (v0.x - v2.x) * (y - v2.y)) / area;
          const w2 = 1 - w0 - w1;
          if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
            const sx = w0 * o0.x + w1 * o1.x + w2 * o2.x;
            const sy = w0 * o0.y + w1 * o1.y + w2 * o2.y;
            const [r, g, b, a] = sampleBilinear(imgData.data, sx, sy);
            const idx = (y * outW + x) * 4;
            outBuf[idx] = r;
            outBuf[idx + 1] = g;
            outBuf[idx + 2] = b;
            outBuf[idx + 3] = a;
          }
        }
      }
    } catch (err) {
      showError('三角形描画エラー: ' + err.message);
    }
  }

  // 描画本体
  function draw() {
    if (!imgData) return;
    try {
      const w = canvas.width, h = canvas.height;
      const output = ctx.createImageData(w, h);
      const buf = output.data;

      for (let gy = 0; gy < gridY; gy++) {
        for (let gx = 0; gx < gridX; gx++) {
          const i = gy * (gridX + 1) + gx;
          const p1 = gridPoints[i], p2 = gridPoints[i + 1],
                p3 = gridPoints[i + gridX + 1], p4 = gridPoints[i + gridX + 2];
          const o1 = { x: p1.origX, y: p1.origY }, o2 = { x: p2.origX, y: p2.origY },
                o3 = { x: p3.origX, y: p3.origY }, o4 = { x: p4.origX, y: p4.origY };
          drawTriangle(p1, p2, p3, o1, o2, o3, buf, w, h);
          drawTriangle(p4, p3, p2, o4, o3, o2, buf, w, h);
        }
      }

      // 簡易境界埋め
      const tmp = new Uint8ClampedArray(buf);
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = (y * w + x) * 4;
          if (buf[idx + 3] < 10) {
            let sr = 0, sg = 0, sb = 0, sa = 0, cnt = 0;
            [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dx, dy]) => {
              const j = ((y + dy) * w + (x + dx)) * 4;
              if (tmp[j + 3] > 200) {
                sr += tmp[j];
                sg += tmp[j + 1];
                sb += tmp[j + 2];
                sa += tmp[j + 3];
                cnt++;
              }
            });
            if (cnt) {
              buf[idx] = sr / cnt;
              buf[idx + 1] = sg / cnt;
              buf[idx + 2] = sb / cnt;
              buf[idx + 3] = sa / cnt;
            }
          }
        }
      }

      ctx.putImageData(output, 0, 0);
      ctx.drawImage(drawCanvas, 0, 0);
      console.log('描画完了');
    } catch (err) {
      showError('描画エラー: ' + err.message);
    }
  }

  // 保存
  function saveImage() {
    try {
      const a = document.createElement('a');
      a.href = canvas.toDataURL();
      a.download = 'warped.png';
      a.click();
    } catch (err) {
      showError('保存エラー: ' + err.message);
    }
  }
  </script>
</body>
</html>

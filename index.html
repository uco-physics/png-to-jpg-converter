```html
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>メッシュワープ＋ペン描画（コミットツリー版）</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    #container { position: relative; display: inline-block; }
    canvas { border: 3px solid #000; background: #f0f0f0; cursor: crosshair; }
    #gridContainer {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .grid-point {
      position: absolute; width: 10px; height: 10px;
      background: rgba(255,0,0,0.8); border-radius:50%;
      transform: translate(-50%,-50%); cursor: move;
      pointer-events: auto;
    }
    .controls { margin: 20px 0; }
    .controls > * { margin: 0 5px; vertical-align: middle; }
    #error { color: red; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>メッシュワープ＋ペン描画（コミットツリー版）</h1>
  <div class="controls">
    <input type="file" id="imageInput" accept="image/*">
    <label>横分割: <input type="range" id="gridX" min="2" max="50" value="5">
      <span id="gridXValue">5</span></label>
    <label>縦分割: <input type="range" id="gridY" min="2" max="50" value="5">
      <span id="gridYValue">5</span></label>
    <button id="applyGridBtn">グリッド更新</button>
    <button id="undoBtn">戻る</button>
    <button id="redoBtn">進む</button>
    <button id="resetBtn">リセット</button>
    <button id="saveBtn">保存</button>
    <!-- ペン描画ツール -->
    <select id="toolSelect">
      <option value="edit">グリッド編集</option>
      <option value="pen">ペン</option>
      <option value="eraser">消しゴム</option>
    </select>
    <input type="color" id="colorPicker" value="#ff0000">
    <label>太さ: <input type="range" id="thickness" min="1" max="50" value="5"></label>
    <div id="error"></div>
  </div>

  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="gridContainer"></div>
  </div>

  <script>
    // --- Commit クラス（コミットツリー管理） ---
    class Commit {
      constructor(parent, imgData, gridX, gridY, initialPoints) {
        this.parent    = parent;
        this.children  = [];
        this.imgData   = imgData;       // ImageData at this commit
        this.gridX     = gridX;
        this.gridY     = gridY;
        this.snapshots = [];
        this.idx       = -1;
        this.push(initialPoints);
      }
      push(points) {
        this.snapshots = this.snapshots.slice(0, this.idx + 1);
        this.snapshots.push(points.map(p => ({ x:p.x, y:p.y, origX:p.origX, origY:p.origY })));
        this.idx++;
      }
      currentPoints() {
        return this.snapshots[this.idx].map(p => ({ ...p }));
      }
    }

    // --- DOM Elements ---
    const canvas       = document.getElementById('canvas');
    const ctx          = canvas.getContext('2d');
    const imgInput     = document.getElementById('imageInput');
    const gridXInput   = document.getElementById('gridX');
    const gridYInput   = document.getElementById('gridY');
    const gridXValueEl = document.getElementById('gridXValue');
    const gridYValueEl = document.getElementById('gridYValue');
    const applyGridBtn = document.getElementById('applyGridBtn');
    const undoBtn      = document.getElementById('undoBtn');
    const redoBtn      = document.getElementById('redoBtn');
    const resetBtn     = document.getElementById('resetBtn');
    const saveBtn      = document.getElementById('saveBtn');
    const toolSelect   = document.getElementById('toolSelect');
    const colorPicker  = document.getElementById('colorPicker');
    const thicknessInp = document.getElementById('thickness');
    const gridContainer= document.getElementById('gridContainer');
    const errorDiv     = document.getElementById('error');

    // --- State Variables ---
    let img           = new Image();
    let imgData       = null;      // ベース画像データ（コミット済み）
    let gridPoints    = [];        // 現在のポイント配列
    let pendingX = 5, pendingY = 5; // スライダーの未適用値

    let rootCommit    = null;
    let currentCommit = null;

    let isDragging    = false, dragIdx = null;
    let tool          = 'edit';
    let strokeColor   = '#ff0000';
    let strokeWidth   = 5;

    // 描画用オフスクリーンキャンバス（ストローク保持）
    const strokeCanvas = document.createElement('canvas');
    const strokeCtx    = strokeCanvas.getContext('2d');

    // --- ヘルパー Functions ---
    function showError(msg) {
      errorDiv.textContent = msg;
      console.error(msg);
    }
    function barycentric(v0,v1,v2, x,y) {
      const area = (v1.y-v2.y)*(v0.x-v2.x)+(v2.x-v1.x)*(v0.y-v2.y);
      const w0 = ((v1.y-v2.y)*(x-v2.x)+(v2.x-v1.x)*(y-v2.y))/area;
      const w1 = ((v2.y-v0.y)*(x-v2.x)+(v0.x-v2.x)*(y-v2.y))/area;
      const w2 = 1 - w0 - w1;
      return (w0>=0 && w1>=0 && w2>=0) ? { w0,w1,w2 } : null;
    }
    // 変形後座標→元画像座標
    function destToOrig(px,py) {
      const w=canvas.width, h=canvas.height;
      const gx = Math.min(currentCommit.gridX-1, Math.floor(px/(w/currentCommit.gridX)));
      const gy = Math.min(currentCommit.gridY-1, Math.floor(py/(h/currentCommit.gridY)));
      const i = gy*(currentCommit.gridX+1)+gx;
      const p1 = gridPoints[i],     p2 = gridPoints[i+1],
            p3 = gridPoints[i+currentCommit.gridX+1],
            p4 = gridPoints[i+currentCommit.gridX+2];
      const o1={x:p1.origX,y:p1.origY},
            o2={x:p2.origX,y:p2.origY},
            o3={x:p3.origX,y:p3.origY},
            o4={x:p4.origX,y:p4.origY};
      let bc = barycentric(p1,p2,p3, px,py);
      if (bc) {
        return {
          x: bc.w0*o1.x + bc.w1*o2.x + bc.w2*o3.x,
          y: bc.w0*o1.y + bc.w1*o2.y + bc.w2*o3.y
        };
      }
      bc = barycentric(p4,p3,p2, px,py);
      if (bc) {
        return {
          x: bc.w0*o4.x + bc.w1*o3.x + bc.w2*o2.x,
          y: bc.w0*o4.y + bc.w1*o3.y + bc.w2*o2.y
        };
      }
      // 外側ならそのまま
      return { x:px, y:py };
    }
    // バイリニアサンプリング
    function sampleBilinear(buf, sx, sy) {
      const w=canvas.width, h=canvas.height;
      sx = Math.max(0, Math.min(w-1, sx));
      sy = Math.max(0, Math.min(h-1, sy));
      const x0 = Math.floor(sx), y0 = Math.floor(sy);
      const x1 = Math.min(w-1, x0+1), y1 = Math.min(h-1, y0+1);
      const dx = sx - x0, dy = sy - y0;
      const i00=(y0*w+x0)*4, i10=(y0*w+x1)*4,
            i01=(y1*w+x0)*4, i11=(y1*w+x1)*4;
      const c00=[buf[i00],buf[i00+1],buf[i00+2],buf[i00+3]];
      const c10=[buf[i10],buf[i10+1],buf[i10+2],buf[i10+3]];
      const c01=[buf[i01],buf[i01+1],buf[i01+2],buf[i01+3]];
      const c11=[buf[i11],buf[i11+1],buf[i11+2],buf[i11+3]];
      const mix=(a,b,t)=>a+(b-a)*t;
      const r = mix(mix(c00[0],c10[0],dx), mix(c01[0],c11[0],dx), dy);
      const g = mix(mix(c00[1],c10[1],dx), mix(c01[1],c11[1],dx), dy);
      const b = mix(mix(c00[2],c10[2],dx), mix(c01[2],c11[2],dx), dy);
      const a = mix(mix(c00[3],c10[3],dx), mix(c01[3],c11[3],dx), dy);
      return [r,g,b,a];
    }
    // 三角形逆写像＋ストローク合成
    function drawTriangle(v0,v1,v2,o0,o1,o2, baseBuf, strokeBuf, outBuf, w,h) {
      const minX = Math.max(0,Math.floor(Math.min(v0.x,v1.x,v2.x)));
      const maxX = Math.min(w-1,Math.ceil (Math.max(v0.x,v1.x,v2.x)));
      const minY = Math.max(0,Math.floor(Math.min(v0.y,v1.y,v2.y)));
      const maxY = Math.min(h-1,Math.ceil (Math.max(v0.y,v1.y,v2.y)));
      const area = (v1.y-v2.y)*(v0.x-v2.x)+(v2.x-v1.x)*(v0.y-v2.y);
      for(let y=minY; y<=maxY; y++){
        for(let x=minX; x<=maxX; x++){
          const w0 = ((v1.y-v2.y)*(x-v2.x)+(v2.x-v1.x)*(y-v2.y))/area;
          const w1 = ((v2.y-v0.y)*(x-v2.x)+(v0.x-v2.x)*(y-v2.y))/area;
          const w2 = 1 - w0 - w1;
          if(w0>=0 && w1>=0 && w2>=0){
            const sx = w0*o0.x + w1*o1.x + w2*o2.x;
            const sy = w0*o0.y + w1*o1.y + w2*o2.y;
            const [r,g,b,a] = sampleBilinear(baseBuf, sx, sy);
            const [sr,sg,sb,sa] = sampleBilinear(strokeBuf, sx, sy);
            const alpha = sa/255;
            const rr = sr*alpha + r*(1-alpha);
            const gg = sg*alpha + g*(1-alpha);
            const bb = sb*alpha + b*(1-alpha);
            const outIdx = (y*w + x)*4;
            outBuf[outIdx]   = rr;
            outBuf[outIdx+1] = gg;
            outBuf[outIdx+2] = bb;
            outBuf[outIdx+3] = 255;
          }
        }
      }
    }

    // --- 描画本体 ---
    function draw() {
      if (!imgData) return;
      const w = canvas.width, h = canvas.height;
      const output = ctx.createImageData(w,h);
      const outBuf = output.data;
      const baseBuf   = imgData.data;
      const strokeBuf = strokeCtx.getImageData(0,0,w,h).data;

      for (let gy=0; gy<currentCommit.gridY; gy++){
        for (let gx=0; gx<currentCommit.gridX; gx++){
          const i = gy*(currentCommit.gridX+1)+gx;
          const p1 = gridPoints[i],     p2 = gridPoints[i+1],
                p3 = gridPoints[i+currentCommit.gridX+1],
                p4 = gridPoints[i+currentCommit.gridX+2];
          const o1={x:p1.origX,y:p1.origY},
                o2={x:p2.origX,y:p2.origY},
                o3={x:p3.origX,y:p3.origY},
                o4={x:p4.origX,y:p4.origY};
          drawTriangle(p1,p2,p3, o1,o2,o3, baseBuf, strokeBuf, outBuf, w,h);
          drawTriangle(p4,p3,p2, o4,o3,o2, baseBuf, strokeBuf, outBuf, w,h);
        }
      }
      ctx.putImageData(output,0,0);
    }

    // --- グリッド DOM 管理 ---
    function createPoint(x,y,i){
      const d = document.createElement('div');
      d.className = 'grid-point';
      d.style.left = x + 'px';
      d.style.top  = y + 'px';
      d.onmousedown = () => {
        if (tool === 'edit') {
          isDragging = true;
          dragIdx = i;
        }
      };
      gridContainer.appendChild(d);
    }
    function initGridCommit(commit) {
      // ベース画像を描画
      ctx.putImageData(commit.imgData,0,0);
      imgData = commit.imgData;
      // グリッド数反映
      gridXInput.value = commit.gridX;
      gridYInput.value = commit.gridY;
      gridXValueEl.textContent = commit.gridX;
      gridYValueEl.textContent = commit.gridY;
      pendingX = commit.gridX;
      pendingY = commit.gridY;
      // gridPoints 読み込み
      gridPoints = commit.currentPoints();
      // DOM 再構築
      gridContainer.innerHTML = '';
      for (let i=0; i<gridPoints.length; i++){
        createPoint(gridPoints[i].x, gridPoints[i].y, i);
      }
      draw();
    }

    // --- イベントリスナ ---    
    imgInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return showError('画像を選択してください');
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        canvas.width  = img.width;
        canvas.height = img.height;
        strokeCanvas.width  = img.width;
        strokeCanvas.height = img.height;
        strokeCtx.clearRect(0,0,img.width,img.height);

        // 初期ベースをキャッシュ
        ctx.drawImage(img,0,0);
        const base = ctx.getImageData(0,0,canvas.width,canvas.height);

        // 初期グリッドポイント
        const initPts = [];
        const gx = +gridXInput.value, gy = +gridYInput.value;
        for (let y=0; y<=gy; y++){
          for (let x=0; x<=gx; x++){
            initPts.push({
              x: x*(canvas.width/gx),
              y: y*(canvas.height/gy),
              origX: x*(canvas.width/gx),
              origY: y*(canvas.height/gy)
            });
          }
        }
        // ルートコミット生成
        rootCommit    = new Commit(null, base, gx, gy, initPts);
        currentCommit = rootCommit;
        initGridCommit(rootCommit);
      };
      img.onerror = () => showError('画像読み込み失敗');
    });

    applyGridBtn.addEventListener('click', () => {
      // 現在キャンバス(合成画像)を新ベースに
      const newBase = ctx.getImageData(0,0,canvas.width,canvas.height);
      // グリッド数適用
      const nx = pendingX, ny = pendingY;
      // 新グリッド初期化ポイント
      const pts = [];
      for (let y=0; y<=ny; y++){
        for (let x=0; x<=nx; x++){
          pts.push({
            x: x*(canvas.width/nx),
            y: y*(canvas.height/ny),
            origX: x*(canvas.width/nx),
            origY: y*(canvas.height/ny)
          });
        }
      }
      // 新コミット
      const c = new Commit(currentCommit, newBase, nx, ny, pts);
      currentCommit.children.push(c);
      currentCommit = c;
      // ストロークはベースに焼き込まれたのでクリア
      strokeCtx.clearRect(0,0,canvas.width,canvas.height);
      initGridCommit(c);
    });

    undoBtn.addEventListener('click', () => {
      if (!currentCommit) return;
      if (currentCommit.idx > 0) {
        currentCommit.idx--;
      } else if (currentCommit.parent) {
        currentCommit = currentCommit.parent;
      }
      initGridCommit(currentCommit);
    });

    redoBtn.addEventListener('click', () => {
      if (!currentCommit) return;
      if (currentCommit.idx < currentCommit.snapshots.length - 1) {
        currentCommit.idx++;
      } else if (currentCommit.children.length === 1) {
        currentCommit = currentCommit.children[0];
      }
      initGridCommit(currentCommit);
    });

    resetBtn.addEventListener('click', () => {
      if (!currentCommit) return;
      currentCommit.idx = 0;
      initGridCommit(currentCommit);
    });

    saveBtn.addEventListener('click', () => {
      const a = document.createElement('a');
      a.href = canvas.toDataURL();
      a.download = 'warped.png';
      a.click();
    });

    // ツール切替
    toolSelect.addEventListener('change', e => {
      tool = e.target.value;
      // グリッド編集モード以外ではポイント操作無効
      Array.from(gridContainer.children).forEach(pt => {
        pt.style.pointerEvents = (tool === 'edit' ? 'auto' : 'none');
      });
      canvas.style.cursor = (tool === 'edit' ? 'default' : 'crosshair');
    });
    colorPicker.addEventListener('input', e => strokeColor = e.target.value);
    thicknessInp.addEventListener('input', e => strokeWidth = +e.target.value);

    // ドラッグ（グリッド移動 or 描画）
    let drawing = false;
    canvas.addEventListener('mousedown', e => {
      if (tool === 'pen' || tool === 'eraser') {
        drawing = true;
        strokeCtx.beginPath();
        strokeCtx.globalCompositeOperation = (tool === 'eraser' ? 'destination-out' : 'source-over');
        strokeCtx.lineWidth = (tool === 'eraser' ? strokeWidth*2 : strokeWidth);
        strokeCtx.strokeStyle = strokeColor;
        const {x:ox,y:oy} = destToOrig(e.offsetX, e.offsetY);
        strokeCtx.moveTo(ox, oy);
        // その場で反映
        draw();
      }
    });
    canvas.addEventListener('mousemove', e => {
      if (drawing) {
        const {x:ox,y:oy} = destToOrig(e.offsetX, e.offsetY);
        strokeCtx.lineTo(ox, oy);
        strokeCtx.stroke();
        draw();
      }
      if (isDragging && dragIdx !== null) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const p = gridPoints[dragIdx];
        p.x = Math.max(0, Math.min(canvas.width, x));
        p.y = Math.max(0, Math.min(canvas.height, y));
        const d = gridContainer.children[dragIdx];
        d.style.left = p.x + 'px';
        d.style.top  = p.y + 'px';
        currentCommit.push(gridPoints);
        draw();
      }
    });
    document.addEventListener('mouseup', () => {
      if (drawing) {
        drawing = false;
        strokeCtx.globalCompositeOperation = 'source-over';
      }
      if (isDragging) {
        isDragging = false;
        dragIdx = null;
      }
    });
  </script>
</body>
</html>
```
